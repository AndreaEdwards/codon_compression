"""
Copyright (c) 2016, Andrea Halweg-Edwards, Gur Pines, Assaf Pines, James Winkler
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of DYNAMCC nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

from time import time
from collections import defaultdict
# this is a codon usage dictionary that is generated by the current program.
# in this case, the user has selected to remove the amino acid C and only wants 
# the codons with ranking of 3 or higher (i.e. the first three codons with 
# the highest usage)
dictionary = {'A': [{'GCC': '0.45'}, {'GCT': '0.19'}, {'GCG': '0.19'}], 'E': [{'GAG': '0.67'}, {'GAA': '0.33'}],
              'D': [{'GAT': '0.53'}, {'GAC': '0.47'}], 'G': [{'GGC': '0.43'}, {'GGA': '0.29'}, {'GGT': '0.21'}],
              'F': [{'TTC': '0.63'}, {'TTT': '0.37'}], 'I': [{'ATC': '0.47'}, {'ATT': '0.34'}, {'ATA': '0.19'}],
              'H': [{'CAC': '0.6'}, {'CAT': '0.4'}], 'K': [{'AAG': '0.71'}, {'AAA': '0.29'}], 'M': [{'ATG': '1'}],
              'L': [{'CTG': '0.43'}, {'TTG': '0.18'}, {'CTC': '0.15'}], 'N': [{'AAC': '0.56'}, {'AAT': '0.44'}],
              'Q': [{'CAG': '0.7'}, {'CAA': '0.3'}], 'P': [{'CCC': '0.33'}, {'CCG': '0.29'}, {'CCA': '0.25'}],
              'S': [{'AGC': '0.25'}, {'TCC': '0.24'}, {'TCG': '0.2'}],
              'R': [{'CGC': '0.33'}, {'CGT': '0.16'}, {'CGA': '0.15'}],
              'T': [{'ACC': '0.38'}, {'ACG': '0.26'}, {'ACA': '0.19'}], 'W': [{'TGG': '1'}],
              'V': [{'GTG': '0.47'}, {'GTC': '0.24'}, {'GTT': '0.18'}], 'Y': [{'TAC': '0.63'}, {'TAT': '0.37'}],
              'X': [{'TAA': '0.42'}, {'TAG': '0.32'}, {'TGA': '0.26'}]}

rules_dict = {'AC': 'M', 'GT': 'K', 'ACG': 'V', 'ACGT': 'N', 'AG': 'R', 'CG': 'S', 'AT': 'W', 'ACT': 'H',
              'AGT': 'D', 'CGT': 'B', 'CT': 'Y'}

inverse_dict = {}

for key in rules_dict:
    inverse_dict[rules_dict[key]] = key

# your job is to write a script that finds every possible combination of these 
# codons. the information we are really interested in is the length of the
# compressed codon list (we want the shortest list) and the sum of the 
# codon usage frequencies of codons in the compressed list

# below is the function that I need help on. "DoWork". 
# currently, it does not work correctly
# it is sampling some combinations more than once, and skipping other combinations

position_cache = defaultdict(dict)

position_result_cache = {}

list_to_group_cache = {}

cached_position = 0
uncached_position = 0

def DoWork(codon_count, idx, processes, empty_list, new_dict, redundancy, rank, GlobalStart):
    """
    Parameters
    ----------
    idx : int
        probably short for index. this is the process number we are on
    """
    print("Thread " + str(processes) + " starting")
    BestReduceSize = 20
    BestRatio = 0
    BestIndex = 0
    t = 0
    previous = 0

    inverse_rule_dict = {}

    for key in rules_dict:
        inverse_rule_dict[rules_dict[key]] = key

    combinations = codon_exploder(codon_count, rank)
    faster_new_dict = {}

    for key in new_dict:

        codons = new_dict[key]
        #temp_codons = []
        for codon_dict,i in zip(codons,range(0,len(codons))):
            #temp_codons.append({codon_dict.keys()[0]: float(codon_dict.values()[0])})

            if(key not in faster_new_dict):
                faster_new_dict[key] = {}

            faster_new_dict[key][i] = (codon_dict.keys()[0], float(codon_dict.values()[0]))

        #converted_dict[key] = temp_codons

    for combo in combinations:

        codons, ratios = CreateListFromIndex(combo, faster_new_dict)
        t += 1
        if redundancy != 0:
            pass
        else:
            recursive = Recursive(codons)
            reduced_list = recursive.Reduce()
            total_usage_frequency = sum(ratios)
            #or (total_usage_frequency > BestRatio and len(reduced_list) == BestReducedList
            if len(reduced_list) < BestReduceSize:
                BestList = [codons, ratios]
                BestReduceSize = len(reduced_list)
                BestReducedList = reduced_list
                BestIndex = t
                BestRatio = total_usage_frequency

        if (t % 10000 == 0):

            EndTime = time()
            duration = int((EndTime - GlobalStart) * 1000)
            print("thread " + str(processes) +
                  " finished " +
                  str(int(100 * t / 100)) +
                  " % @ " +
                  str(duration) +
                  " ms, delta = " + str(duration - previous) +
                  ", Best Size: " +
                  str(BestReduceSize) +
                  ", Best Index: " +
                  str(BestIndex) +
                  ", Best Ratio: " +
                  str(BestRatio) + ", combinations index = %i" %t)
            previous = int((EndTime - GlobalStart)*1000)

    information_dict = {
        "BestList": BestList,
        "ReducedList" : BestReducedList,
        "ReduceSize": BestReduceSize,
        "Ratio": BestRatio
    }
    print information_dict
    return information_dict

'''
# these are the functions that DoWork relies on
def CreateListFromIndex(empty_list, new_dict):
    codons = []
    ratios = []
    i = 0
    while i < len(empty_list):
        for key1 in new_dict:
            for key2 in new_dict[key1][empty_list[i]]:
                codons.append(key2)
                ratios.append(new_dict[key1][empty_list[i]][key2])
            i += 1
    return codons, ratios
'''

# these are the functions that DoWork relies on
def CreateListFromIndex(empty_list, new_dict):
    codons = [None] * 20
    ratios = [None] * 20

    counter = 0
    for aa in new_dict:
        #print aa,empty_list[i],empty_list,i
        (codon, ratio) = new_dict[aa][empty_list[counter]]
        codons[counter] = codon
        ratios[counter] = ratio
        counter+=1

    return codons, ratios


class Recursive:
    def __init__(self, codon_list):
        """Initialize the Recursive object with two parameters.

        Parameters
        ----------
        codon_list: list
            list of codons that are most frequently used after removing codons
            corresponding to amino acids (or stop codon) that the user has
            specified they want left out. This list can be the result of
            running BestList
        rules_dict: dict
            dictionary in which the key is a string resulting from joining the
            nucleotides (A, G, C, T) in columns 2-5 of each line from the .rul
            file and the value corresponds to the string in the first column of
            each line of the .rul file

        Returns
        -------
        none

        Examples
        --------
        """
        self.codon_list = codon_list
        self.reduced = []
        self.my_dict = {}

    def FindMinList(self, list):
        """Recursive algorithm in which the self.codon_list is a list of the
        most frequently used codons for amino acids that the user wants to
        include for compression. self.codon is initially the list passed in
        when instantiating the Recursive class. This list is copied to the
        variable temp for downstream comparison. Then, Reduce() is called and
        the resulting list is captured in the variable reduced_list. The two
        lists are compared and if not equal, FindMinList recurses by calling
        itself and passing the new list (captured from Reduce()) in as the
        argument. When temp and reduced_list are equal, the method returns the
        updated self.codon_list (this member variable is modified in Reduce())

        Parameters
        ----------
        list: list
            This is a codon list, it can correspond to any codon list such as
            the most frequently used codons staged for compression or the
            semi-compressed list resulting from Reduce()

        Returns
        -------
        self.codon_list: list
            The updated codon list. This list represents the most compressed
            set of codons remaining after running the recursive algorithm once
            through. (need better description of this)

        Examples
        --------
        """

        temp = self.codon_list
        reduced_list = self.Reduce()
        if temp != reduced_list:
            self.FindMinList(reduced_list)
        return self.codon_list

    def Reduce(self):
        """Iterate through each position in the codon. At each position,
        capture the result of Grouping(int) in self.my_dict. Pass this dict to
        ListFromGroup(dict, int) and capture the result in self.codon_list. Return
        self.codon_list after iterating through each position in the codon.

        Parameters
        ----------
        none

        Returns
        -------
        self.codon_list: list
            The updated codon list. This list represents the most compressed
            set of codons remaining after running Grouping(int) and
            ListFromGroup(dict, int) for all three codon positions

        Examples
        --------
        reduced_list = self.Reduce()

        """
        for i in [0,1,2]:
            my_dict = self.Grouping(i, self.codon_list, inverse_dict)
            self.codon_list = self.ListFromGroup(my_dict, i)
            self.my_dict = my_dict
        return self.codon_list

    def Grouping(self, int, codon_list, inverse_dict):

        """
        This function initializes an empty dict. Then iterates through each
        codon in self.codon_list. The code then branches depending on which
        codon position was passed in (0, 1, or 2). If int == 0, InRules == 0
        and the codon is split into two variables ('position' == the first
        position and 'remainder' == the rest of the codon). Then it iterates
        through the keys in self.rules_dict and checks if the value is equal to
        the position. If so, then it adds a new key-value pair to the local
        my_dict variable. The key corresponds to the "remainder" and the value
        is a set that contains the split key from self.rules_dict and the
        InRules variable is set to 1. If the value in self.rules_dict is not
        equivalent to the position, then nothing happens. After exiting the
        if branch, the script checks whether InRules is 1 or 0. If 0, then
        my_dict is extended. If a key already exists in this dict with the
        same value as the remainder, then the value of that key is (which is
        a set) is extended to include the new value of the position variable.
        If not, then a new key-value pair is added. The logic is the same for
        int == 1 and int == 2. The script then iterates through the keys in
        my_dict and joins the value's strings.

        Parameters
        ----------
        int : int
            This should be a 0, 1, or 2 (depending on what is being passed
            from Reduce()). Because we are interested in positions in the
            codons, it does not make sense to have numbers other than 0, 1,
            or 2. There should be error handling here.

        Returns
        -------
        self.my_dict : dict
            A dictionary in which the keys are strings of nucleotides that fall
            at particular positions in the codon (1,2 or 0,2 or 0,1) and the
            values are all the nucleotides that can exist at the remaining
            position. Here the key-value pairs represent compressed codons.

            For example, the first iteration through looks like:
            {'AA': 'AGT', 'AC': 'A', 'GT': 'C', 'AG': 'C', 'CC': 'A',
            'TT': 'AT', 'CG': 'CG', 'GG': 'T', 'GC': 'AG', 'AT': 'CGT',
            'TG': 'ACG'}

            And the last iteration through looks like:
            {'BA': 'T', 'CG': 'T', 'CA': 'G', 'AM': 'C', 'DA': 'A',
            'RG': 'C', 'WT': 'T', 'VT': 'G', 'SC': 'G', 'TG': 'G'}

        Examples
        --------
        """

        array_slice = set([0, 1, 2])
        idx = list(array_slice - set([int]))

        temp_dict = defaultdict(set)
        my_dict = {}

        all_in = True
        '''
        for codon in codon_list:

            try:
                remainder = position_cache[codon][int]
                my_dict[remainder] = position_result_cache[remainder]
                #temp_dict[remainder].add(inverse_dict[codon[int]])
            except:
                all_in = False
                temp_dict = defaultdict(set)
                break

        if(not all_in):
        '''
        for codon in codon_list:
            position = codon[int]
            try:
                remainder = position_cache[codon][int]
            except:
                remainder = codon[idx[0]] + codon[idx[1]]
                position_cache[codon][int] = remainder

            if(position in inverse_dict):
                temp_dict[remainder].add(inverse_dict[position])
            else:
                temp_dict[remainder].add(position)
        #else:
        #    return my_dict

        for key in temp_dict:

            if len(temp_dict[key]) > 1:
                my_dict[key] = ''.join(sorted(temp_dict[key]))
            else:
                my_dict[key] = temp_dict[key].pop()

            #position_result_cache[key] = my_dict[key]

        #self.my_dict = my_dict
        return my_dict

    def ListFromGroup(self, my_dict, int):
        """This function initializes an empty list. Then iterates through the
        keys in the member variable self.my_dict (which was modified in
        Grouping(int)) and captures the value in the variable temp. The code
        then branches depending on what integer was passed in (0, 1, or 2).
        If 0, it checks whether the value (a string) is longer than 1. If it
        is, then it finds the value from the member variable self.rules_dict
        and concatenates it with the key from self.my_dict. The concatenated
        product is then captured in the variable 'new_codon'. If it is not
        longer than one (i.e. only one nucleotide will work at that particular
        position in the compressed codon), then the value at self.my_dict[key]
        is concatenated with the key from self.my_dict and this concatenated
        product is captured in the variable 'new_codon'. new_codon is then
        added to the new_list. Logic is similar for int values of 1 or 2.

        Parameters
        ----------
        my_dict : dict
            This dictionary has a string as the key and string as value. The
            dictionary should be the same format as the output from Grouping()
        int : int
            This should be a 0, 1, or 2. Because we are interested in positions
            in the codons, it does not make sense to have numbers other than
            0, 1, or 2. There should be error handling here.

        Returns
        -------
        new_list : list
            A list of compressed codons

        """
        new_list = [None] * len(my_dict)

        counter = 0

        for key in my_dict:
            temp = my_dict[key]

            if len(temp) > 1:
                if int == 0:
                    new_codon = rules_dict[temp]+key
                elif int == 1:
                    new_codon = key[0] + rules_dict[temp] + key[1]
                else:
                    new_codon = key + rules_dict[temp]
            else:
                if int == 0:
                    new_codon = temp + key
                elif int == 1:
                    new_codon = key[0] + temp + key[1]
                else:
                    new_codon = key + temp

            '''

            try:
                new_codon = list_to_group_cache[key][int]
            except:
                if len(temp) > 1:
                    if int == 0:
                        new_codon = rules_dict[temp]+key
                    elif int == 1:
                        new_codon = key[0] + rules_dict[temp] + key[1]
                    else:
                        new_codon = key + rules_dict[temp]
                else:
                    if int == 0:
                        new_codon = temp + key
                    elif int == 1:
                        new_codon = key[0] + temp + key[1]
                    else:
                        new_codon = key + temp

                list_to_group_cache[key][int] = new_codon

            '''
            new_list[counter] = new_codon
            counter +=1

        return new_list


def codon_exploder(codon_count, rank):
    import itertools

    temp_list = []

    for item in codon_count:

        if(rank+1 <= item):
            temp_list.append(range(0, rank+1))
        else:
            temp_list.append(range(0, item))

    combinations = itertools.product(*temp_list)
    return combinations


def main():

    # codon count represents number of codons per amino acid
    #codon_count = [3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 2, 2, 3, 3, 3, 3, 1, 3, 2, 3]
    codon_count = [3, 2, 2, 3, 2, 3, 2, 2, 1, 3, 2, 2, 1, 1, 1, 3, 1, 3, 2, 3]
    idx = 0
    processes = 1
    empty_list = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

    # same as the dictionary above.. this is the most important piece of information. if you can figure out how to get at the answer without all the other garbage.. that would be awesome.
    new_dict = {'A': [{'GCG': '0.33'}, {'GCC': '0.26'}, {'GCA': '0.23'}], 'E': [{'GAA': '0.68'}, {'GAG': '0.32'}],
                'D': [{'GAT': '0.63'}, {'GAC': '0.37'}], 'G': [{'GGC': '0.37'}, {'GGT': '0.35'}, {'GGG': '0.15'}],
                'F': [{'TTT': '0.58'}, {'TTC': '0.42'}], 'I': [{'ATT': '0.49'}, {'ATC': '0.39'}, {'ATA': '0.11'}],
                'H': [{'CAT': '0.57'}, {'CAC': '0.43'}], 'K': [{'AAA': '0.74'}, {'AAG': '0.26'}], 'M': [{'ATG': '1'}],
                'L': [{'CTG': '0.47'}, {'TTA': '0.14'}, {'TTG': '0.13'}], 'N': [{'AAC': '0.51'}, {'AAT': '0.49'}],
                'Q': [{'CAG': '0.66'}, {'CAA': '0.34'}], 'P': [{'CCG': '0.49'}, {'CCA': '0.2'}, {'CCT': '0.18'}],
                'S': [{'AGC': '0.25'}, {'TCT': '0.17'}, {'AGT': '0.16'}],
                'R': [{'CGT': '0.36'}, {'CGC': '0.36'}, {'CGG': '0.11'}],
                'T': [{'ACC': '0.4'}, {'ACG': '0.25'}, {'ACT': '0.19'}], 'W': [{'TGG': '1'}],
                'V': [{'GTG': '0.35'}, {'GTT': '0.28'}, {'GTC': '0.2'}], 'Y': [{'TAT': '0.59'}, {'TAC': '0.41'}],
                'X': [{'TAA': '0.61'}, {'TGA': '0.3'}, {'TAG': '0.09'}]}
    redundancy = 0

    tot_combinations = 15116544
    GlobalStart = time()
    rank = 2
    DoWork(codon_count, idx, processes, empty_list, new_dict, redundancy, rank, GlobalStart)

main()
